# 一、内存管理

计算机开机：

<img src="计算机操作系统.assets/c49d493ca86c9b3b1ad9a14842b775b.webp" alt="c49d493ca86c9b3b1ad9a14842b775b" style="zoom: 33%;" />

<img src="计算机操作系统.assets/556359297846571e9f34272ac46198b.webp" alt="556359297846571e9f34272ac46198b" style="zoom: 33%;" />

<img src="计算机操作系统.assets/7f5d9febdfd99f9eeedf8888aa07924.webp" alt="7f5d9febdfd99f9eeedf8888aa07924" style="zoom:33%;" />

OS特征：

<img src="计算机操作系统.assets/583ebb14a29f3d4e509c4ed2dda6fb6.webp" alt="583ebb14a29f3d4e509c4ed2dda6fb6" style="zoom:33%;" />

<img src="计算机操作系统.assets/45aec6f1a31484740637b90f5397159.webp" alt="45aec6f1a31484740637b90f5397159" style="zoom: 33%;" />

物理地址与逻辑地址

<img src="计算机操作系统.assets/812ce3468692ce4ffa8699ccea264b8.webp" alt="812ce3468692ce4ffa8699ccea264b8" style="zoom:33%;" />

<img src="计算机操作系统.assets/a04d6db21c11eb751d8b7ff6e79e61d.webp" alt="a04d6db21c11eb751d8b7ff6e79e61d" style="zoom:33%;" />

<img src="计算机操作系统.assets/25e5483f58982186e448e1a3f234f41.webp" alt="25e5483f58982186e448e1a3f234f41" style="zoom:33%;" />

## 1、连续内存分配

<img src="计算机操作系统.assets/767e0f1278ed4155bb65bcec4c14e07.webp" alt="767e0f1278ed4155bb65bcec4c14e07" style="zoom:33%;" />

<img src="计算机操作系统.assets/d48d9e87a45dc53bcd5b0eb50c8969c.webp" alt="d48d9e87a45dc53bcd5b0eb50c8969c" style="zoom:33%;" />

### 1.1、第一匹配分配

<img src="计算机操作系统.assets/5fbe34c80626d5288dca38e9fc598da.webp" alt="5fbe34c80626d5288dca38e9fc598da" style="zoom:33%;" />

<img src="计算机操作系统.assets/c9809d33991ad96487aeb156bf6004e.webp" alt="c9809d33991ad96487aeb156bf6004e" style="zoom:33%;" />

### 1.2、最佳匹配分配

<img src="计算机操作系统.assets/1c03137074b3bee31e8bd2f381b345d.webp" alt="1c03137074b3bee31e8bd2f381b345d" style="zoom: 33%;" />

<img src="计算机操作系统.assets/f5a54d8b57c924d08fc407f1c4170d3.webp" alt="f5a54d8b57c924d08fc407f1c4170d3" style="zoom:33%;" />

### 1.3、最差匹配分配

<img src="计算机操作系统.assets/c9c53dafecd1bafd3393d46bce52d6f.webp" alt="c9c53dafecd1bafd3393d46bce52d6f" style="zoom:33%;" />

<img src="计算机操作系统.assets/19d3ac3305bfbd3644822dd3180a296.webp" alt="19d3ac3305bfbd3644822dd3180a296" style="zoom:33%;" />

### 1.4、压缩式、交换式碎片整理

<img src="计算机操作系统.assets/b5b475bc336d61d0a8df0b3634022ec.webp" alt="b5b475bc336d61d0a8df0b3634022ec" style="zoom:33%;" />

<img src="计算机操作系统.assets/94530f757d00361f33ac74ee101cfde.webp" alt="94530f757d00361f33ac74ee101cfde" style="zoom:33%;" />

### 1.5、连续内存分配的缺点

<img src="计算机操作系统.assets/4badf2912a7ee409115d4b452d297bd.webp" alt="4badf2912a7ee409115d4b452d297bd" style="zoom:33%;" />

## 2、非连续内存分配

### 2.1、非连续内存分配的优缺点

<img src="计算机操作系统.assets/5e1d1b5ad96a7c04cb64e765ab15987.webp" alt="5e1d1b5ad96a7c04cb64e765ab15987" style="zoom:33%;" />

<img src="计算机操作系统.assets/3a121d2d9a865bda61bd0a7ce813a85.webp" alt="3a121d2d9a865bda61bd0a7ce813a85" style="zoom:33%;" />

### 2.2、分段

<img src="计算机操作系统.assets/534af16b8ff272c58da9b6f6fb4b05a.webp" alt="534af16b8ff272c58da9b6f6fb4b05a" style="zoom:33%;" />

<img src="计算机操作系统.assets/4a6577d22221fe85e55d14a93ff482e.webp" alt="4a6577d22221fe85e55d14a93ff482e" style="zoom:33%;" />

<img src="计算机操作系统.assets/10124e8ca5b01da3da44e90b167b742.webp" alt="10124e8ca5b01da3da44e90b167b742" style="zoom:33%;" />

### 2.3、==分页==

<img src="计算机操作系统.assets/f0f187f95ceddc88ab4ec80095fa8f3.webp" alt="f0f187f95ceddc88ab4ec80095fa8f3" style="zoom:33%;" />

#### 2.3.1、帧

<img src="计算机操作系统.assets/6db6c366977a0c3bce6e5ff0d791fce.webp" alt="6db6c366977a0c3bce6e5ff0d791fce" style="zoom:33%;" />

<img src="计算机操作系统.assets/a3decd9f673fb0e404e6c64fd9a7bd5.webp" alt="a3decd9f673fb0e404e6c64fd9a7bd5" style="zoom:33%;" />

#### 2.3.2、页

<img src="计算机操作系统.assets/ce7efa1ba8b38097f43fd6e2ed3f376.webp" alt="ce7efa1ba8b38097f43fd6e2ed3f376" style="zoom:33%;" />

<img src="计算机操作系统.assets/44d5803f82e501f3cd12742ff917ef1.webp" alt="44d5803f82e501f3cd12742ff917ef1" style="zoom:33%;" />

<img src="计算机操作系统.assets/1e080bf6315b38a85e0deee0081e47b.webp" alt="1e080bf6315b38a85e0deee0081e47b" style="zoom:33%;" />

#### 2.3.3、页表

<img src="计算机操作系统.assets/4f249bb30682d4ce3ce3dc09c262770.webp" alt="4f249bb30682d4ce3ce3dc09c262770" style="zoom:33%;" />

<img src="计算机操作系统.assets/fd66ec3f3714f5980c2f6cd4e7b8b59.webp" alt="fd66ec3f3714f5980c2f6cd4e7b8b59" style="zoom:33%;" />

<img src="计算机操作系统.assets/ad76afbfad2bbc1084d5c42c0c35577.webp" alt="ad76afbfad2bbc1084d5c42c0c35577" style="zoom:33%;" />

#### 2.3.4、快表TLB

<img src="计算机操作系统.assets/a5da356fa2daf879e0b1701e3b67cb3.webp" alt="a5da356fa2daf879e0b1701e3b67cb3" style="zoom:33%;" />

#### 2.3.5、二级、多级页表

<img src="计算机操作系统.assets/147edaaaa53bb85bc99428bf578d453.webp" alt="147edaaaa53bb85bc99428bf578d453" style="zoom:33%;" />

<img src="计算机操作系统.assets/1f9bb57726f9b63d5df73cc63566703.webp" alt="1f9bb57726f9b63d5df73cc63566703" style="zoom:33%;" />

#### 2.3.6、反向页表

<img src="计算机操作系统.assets/f87b9399baf771357d779a68b2617ec.webp" alt="f87b9399baf771357d779a68b2617ec" style="zoom:33%;" />

<img src="计算机操作系统.assets/6811d08a8fcefac6e4d8ca11b2287ea.webp" alt="6811d08a8fcefac6e4d8ca11b2287ea" style="zoom:33%;" />

<img src="计算机操作系统.assets/62c10095722c997c682c613f96df1cd.webp" alt="62c10095722c997c682c613f96df1cd" style="zoom:33%;" />

<img src="计算机操作系统.assets/671bde1cf088ed32461f5c3b489b96a.webp" alt="671bde1cf088ed32461f5c3b489b96a" style="zoom:33%;" />

<img src="计算机操作系统.assets/6428813770d731b2d8ac8cb95315562.webp" alt="6428813770d731b2d8ac8cb95315562" style="zoom:33%;" />

<img src="计算机操作系统.assets/e144290ef8029e0efb63eda55bd4f57.webp" alt="e144290ef8029e0efb63eda55bd4f57" style="zoom:33%;" />

## 3、虚拟内存技术（虚存）

### 3.1、覆盖技术

<img src="计算机操作系统.assets/image-20221119104700168.webp" alt="image-20221119104700168" style="zoom: 50%;" />

<img src="计算机操作系统.assets/image-20221119105045418.webp" alt="image-20221119105045418" style="zoom:50%;" />

### 3.2、交换技术

<img src="计算机操作系统.assets/image-20221119105305719.webp" alt="image-20221119105305719" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119105740007.webp" alt="image-20221119105740007" style="zoom:50%;" />

### 3.3、==虚存技术==

<img src="计算机操作系统.assets/image-20221119110024582.webp" alt="image-20221119110024582" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119110135844.webp" alt="image-20221119110135844" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119110327671.webp" alt="image-20221119110327671" style="zoom:50%;" />

虚存技术的基本概念：

<img src="计算机操作系统.assets/image-20221119110907350.webp" alt="image-20221119110907350" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119113320702.webp" alt="image-20221119113320702" style="zoom: 50%;"/>





#### 3.3.1、虚拟页式内存管理

<img src="计算机操作系统.assets/image-20221119114020143.webp" alt="image-20221119114020143" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119114355697.webp" alt="image-20221119114355697" style="zoom:50%;" />

修改位： 如果修改过，则置为1，否则置为0

访问位： 如果访问过，则置为1，否者置为0

<img src="计算机操作系统.assets/image-20221119114714438.webp" alt="image-20221119114714438" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119114725559.webp" alt="image-20221119114725559" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119115251567.webp" alt="image-20221119115251567" style="zoom:50%;" />

有效存储器访问时间：

<img src="计算机操作系统.assets/image-20221119115743676.webp" alt="image-20221119115743676" style="zoom:50%;" />

#### 3.3.2、局部页面置换算法

功能目标：

<img src="计算机操作系统.assets/image-20221119120133526.webp" alt="image-20221119120133526" style="zoom:50%;" />

##### 3.3.2.1、最优页面置换算法

<img src="计算机操作系统.assets/image-20221119120358424.webp" alt="image-20221119120358424" style="zoom:50%;" />

理想的，无法实现的

下列：d要未来time=10时才执行，最久远，故踢出d

<img src="计算机操作系统.assets/image-20221119120634147.webp" alt="image-20221119120634147" style="zoom:50%;" />

##### 3.3.2.2、先进先出算法(FIFO)

<img src="计算机操作系统.assets/image-20221119120754672.webp" alt="image-20221119120754672" style="zoom:50%;" />

性能较差，替换的可能是经常使用的那个页面

顺序应该为在放入内存中的顺序，而不是执行程序的顺序

eg：注意： 顺序为a->b->c->d

<img src="计算机操作系统.assets/image-20221119121404445.webp" alt="image-20221119121404445" style="zoom:50%;" />

##### 3.3.2.3、最近最久未使用算法LRU(最优算法是根据未来，此算法为根据过去)

<img src="计算机操作系统.assets/image-20221119121708186.webp" alt="image-20221119121708186" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119121840640.webp" alt="image-20221119121840640" style="zoom:50%;" />

需记录各个页面使用时间的先后顺序，开销大

<img src="计算机操作系统.assets/image-20221119122124064.webp" alt="image-20221119122124064" style="zoom:50%;" />

##### 3.3.2.4、==时钟页面置换算法(Clock)==

<img src="计算机操作系统.assets/image-20221119122619875.webp" alt="image-20221119122619875" style="zoom:50%;" />

该算法是对FIFO和LRU的改进

<img src="计算机操作系统.assets/image-20221119123501955.webp" alt="image-20221119123501955" style="zoom:50%;" />

​	注：顺序应该为在放入内存中的顺序，而不是执行程序的顺序

<img src="计算机操作系统.assets/image-20221119124040243.webp" alt="image-20221119124040243" style="zoom:50%;" />

##### 3.3.2.5、二次机会法(对时钟页面置换算法的修改)

二次机会法增加了一个判断指标：dirty bit

修改Clock算法，使它允许脏页总是在一次时钟头扫描中保留下来



需要used bit 和 dirty bit 同时为0才会被丢出内存

指针指向当前：

​	当二者其中一个为1时，将1置为0

​	当二者都为1时，将used bit置为0

<img src="计算机操作系统.assets/image-20221119125457044.webp" alt="image-20221119125457044" style="zoom:50%;" />

当只读时，used bit 置为1

当写时，used bit 和 dirty bit 都置为1

<img src="计算机操作系统.assets/image-20221119130335545.webp" alt="image-20221119130335545" style="zoom:50%;" />

##### 3.3.2.6、最不常用算法(LFU)

<img src="计算机操作系统.assets/image-20221119130755652.webp" alt="image-20221119130755652" style="zoom:50%;" />

#### 3.3.3、Belady现象、LRU、FIFO、Clock的比较

##### 3.3.3.1、Belady现象(了解)

<img src="计算机操作系统.assets/image-20221119131932027.webp" alt="image-20221119131932027" style="zoom:50%;" />

例如下列情况

​	只有量词不缺页情况，后面连续都刚好缺页

<img src="计算机操作系统.assets/image-20221119170401520.webp" alt="image-20221119170401520" style="zoom:50%;" />

##### 3.3.3.2、LRU、FIFO、Clock的比较

<img src="计算机操作系统.assets/image-20221119171354850.webp" alt="image-20221119171354850" style="zoom:50%;" />

#### 3.3.4、工作集模型

<img src="计算机操作系统.assets/image-20221119172805953.webp" alt="image-20221119172805953" style="zoom:50%;" />

##### 3.3.4.1、工作集

<img src="计算机操作系统.assets/image-20221119172854653.webp" alt="image-20221119172854653" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119173248462.webp" alt="image-20221119173248462" style="zoom:50%;" />

##### 3.3.4.2、常驻集

<img src="计算机操作系统.assets/image-20221119173425008.webp" alt="image-20221119173425008" style="zoom:50%;" />

工作集：程序当前进行需要的页面集合

常驻集：当前内存中存在的页面的集合

#### 3.3.5、==两个全局页面置换算法==(适合多个应用程序)

##### 3.3.5.1、工作集置换算法

工作集置换算法：工作集为一个滑动窗口，所有工作集中的页随着工作集的滑动而改变，驻留集也随之改变

<img src="计算机操作系统.assets/image-20221119191942442.webp" alt="image-20221119191942442" style="zoom: 33%;" />

下列工作集窗口大小为4，工作集窗口相当于一个滑动窗口，在工作集窗口内的页放入内存中，否则踢出

<img src="计算机操作系统.assets/image-20221119192155791.webp" alt="image-20221119192155791" style="zoom:50%;" />

##### 3.3.5.2、缺页率页面置换算法

缺页率页面置换算法：由缺页区间决定工作集大小，在工作集中的页在驻留集中

<img src="计算机操作系统.assets/image-20221119192815376.webp" alt="image-20221119192815376" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119193007447.webp" alt="image-20221119193007447" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119193139130.webp" alt="image-20221119193139130" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119194739346.webp" alt="image-20221119194739346" style="zoom:50%;" />

缺页率页面置换算法：由缺页区间决定工作集大小，在工作集中的页在驻留集中

<img src="计算机操作系统.assets/image-20221119195406922.webp" alt="image-20221119195406922" style="zoom:50%;" />



总结：多个应用程序，采用全局页面置换算法要好于局部页面置换算法

#### 3.3.6、抖动问题

<img src="计算机操作系统.assets/image-20221119200239950.webp" alt="image-20221119200239950" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221119200603604.webp" alt="image-20221119200603604" style="zoom:50%;" />

# 二、进程管理

## 1、进程(PROCESS)描述

### 1.1、进程定义

<img src="计算机操作系统.assets/image-20221120214150679.webp" alt="image-20221120214150679" style="zoom:50%;" />

### 1.2、进程的组成

<img src="计算机操作系统.assets/image-20221120214235854.webp" alt="image-20221120214235854" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120214324258.webp" alt="image-20221120214324258" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120214539674.webp" alt="image-20221120214539674" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120214754683.webp" alt="image-20221120214754683" style="zoom:50%;" />

### 1.3、进程的特点

<img src="计算机操作系统.assets/image-20221120215037761.webp" alt="image-20221120215037761" style="zoom:50%;" />

### 1.4、进程控制结构

<img src="计算机操作系统.assets/image-20221120215323709.webp" alt="image-20221120215323709" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120215354758.webp" alt="image-20221120215354758" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120215407467.webp" alt="image-20221120215407467" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120230027420.webp" alt="image-20221120230027420" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120230244294.webp" alt="image-20221120230244294" style="zoom:50%;" />

## 2、进程状态(State)

### 2.1、进程的生命期管理

<img src="计算机操作系统.assets/image-20221120230417936.webp" alt="image-20221120230417936" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120230557086.webp" alt="image-20221120230557086" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120230617104.webp" alt="image-20221120230617104" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120230639886.webp" alt="image-20221120230639886" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120230735695.webp" alt="image-20221120230735695" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221120230755448.webp" alt="image-20221120230755448" style="zoom:50%;" />

### 2.2、进程状态变化模型

<img src="计算机操作系统.assets/image-20221120230902976.webp" alt="image-20221120230902976" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121185015569.webp" alt="image-20221121185015569" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121185027304.webp" alt="image-20221121185027304" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121185232458.webp" alt="image-20221121185232458" style="zoom:50%;" />

速度很快

<img src="计算机操作系统.assets/image-20221121185335737.webp" alt="image-20221121185335737" style="zoom:50%;" />

由操作系统完成

<img src="计算机操作系统.assets/image-20221121185429205.webp" alt="image-20221121185429205" style="zoom:50%;" />

### 2.3、进程挂起

进程没有占用内存空间，成为进程挂起

<img src="计算机操作系统.assets/image-20221121185619508.webp" alt="image-20221121185619508" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121185706308.webp" alt="image-20221121185706308" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121190448130.webp" alt="image-20221121190448130" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121190743567.webp" alt="image-20221121190743567" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121191348586.webp" alt="image-20221121191348586" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121191357063.webp" alt="image-20221121191357063" style="zoom:50%;" />









## 3、==线程(Thread)==

### 3.1、为什么使用线程

<img src="计算机操作系统.assets/image-20221121192006940.webp" alt="image-20221121192006940" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121192139164.webp" alt="image-20221121192139164" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121192234891.webp" alt="image-20221121192234891" style="zoom:50%;" />

### 3.2、线程的定义

<img src="计算机操作系统.assets/image-20221121192309735.webp" alt="image-20221121192309735" style="zoom:50%;" />

进程包括两部分：一部分是资源管理，一部分是线程

一个进程可以包含多个线程，这些线程可以共享这个进程的资源信息

<img src="计算机操作系统.assets/image-20221121192728867.webp" alt="image-20221121192728867" style="zoom:50%;" />

缺点：因为线程可以访问该进程的所有资源，可以改变这些资源相当于破坏了整个进程

<img src="计算机操作系统.assets/image-20221121193300777.webp" alt="image-20221121193300777" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121193518568.webp" alt="image-20221121193518568" style="zoom:50%;" />

### 3.3、线程的实现

<img src="计算机操作系统.assets/image-20221121193654323.webp" alt="image-20221121193654323" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121193800897.webp" alt="image-20221121193800897" style="zoom:50%;" />

#### 3.3.1、用户线程

<img src="计算机操作系统.assets/image-20221121193816047.webp" alt="image-20221121193816047" style="zoom:50%;" />

TCB在用户空间

<img src="计算机操作系统.assets/image-20221121194003948.webp" alt="image-20221121194003948" style="zoom:50%;" />

用户线程不需要操作系统内核来管理(故可用于不支持线程技术的多进程操作系统)，由线程库函数来维护TCB，速度特别快

<img src="计算机操作系统.assets/image-20221121194526935.webp" alt="image-20221121194526935" style="zoom:50%;" />

#### 3.3.2、内核线程

<img src="计算机操作系统.assets/image-20221121194539733.webp" alt="image-20221121194539733" style="zoom: 50%;" />

TCB在内核空间

<img src="计算机操作系统.assets/image-20221121194856795.webp" alt="image-20221121194856795" style="zoom:50%;" />

#### 3.3.3、轻量级进程

<img src="计算机操作系统.assets/image-20221121195028134.webp" alt="image-20221121195028134" style="zoom:50%;" />

一个进程可有一个或多个轻量级进程

### 3.4、上下文切换

<img src="计算机操作系统.assets/image-20221121200004839.webp" alt="image-20221121200004839" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121201325909.webp" alt="image-20221121201325909" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121201356484.webp" alt="image-20221121201356484" style="zoom:50%;" />

### 3.5、==进程控制==

#### 3.5.1、创建进程

**一 进程创建的函数——fork**

<img src="计算机操作系统.assets/image-20221121203018120.webp" alt="image-20221121203018120" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121203211063.webp" alt="image-20221121203211063" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121203336062.webp" alt="image-20221121203336062" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121203434288.webp" alt="image-20221121203434288" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121203700726.webp" alt="image-20221121203700726" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121203925494.webp" alt="image-20221121203925494" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121204026942.webp" alt="image-20221121204026942" style="zoom:50%;" />



可以在父进程使用一个wait()函数，等待子进程执行完毕，回收子进程所占用的资源，避免僵尸进程的出现



**1 OS分配新的内存块和内核数据结构给子进程**
子进程被创建出来之后也是要被操作系统管理起来的，因此OS也会给他分配对应的内存块（task_struct）和内核数据（mm_struct和页表）结构。这时候父子进程各自有各自的内核数据结构了。

**2 将父进程部分（子进程有自己独有的数据，并不一定完全使用父进程的）数据结构中的内容（代码和数据）拷贝（这是一种特殊的拷贝）给子进程。**
由于进程具有独立性，对于子进程使用父进程的代码和数据，从代码层面上看，由于代码是只读的，因此父子共享是没有问题的，不会因为其中一个进程的修改而影响到另一个进程。但是对于数据的话，由于她的属性是可读可写的，那么是不可以被直接拷贝给子进程的，但是子进程又没有自己加载数据的一个过程，这样就很难办了。比方说代码中的大量的全局变量和其他数据，如果父子进程双方都会使用到的话，那么一旦被修改，父子进程中的数据就会跟着被修改了。因此引入了一种技术，叫做写时拷贝技术！

**关于写时拷贝技术：
为么会有写时拷贝技术:**
如果将父进程的数据全部拷贝给子进程的话，有些数据子进程并不会使用到，但是仍然在物理内存中占据着空间，相当于物理内存中有两份一模一样的数据；再者，可能这些数据并不需要写，只需要读，那么这一部分数据没有必要再分配空间；还有，可能即使给子进程分配了对应的物理空间，可能也不会立马被使用。但是又要保证，父子进程的数据是独立的，分离的。这样的话，就引入了这样的一个技术。

那么什么类型的数据必须得被写时拷贝？

将来父进程或者子进程要对其进行写入的数据。

因此，总结：

一般而言，即便是OS也无法在代码还没编译之前就知道，哪些空间可能会被写入。

即便是提前在物理内存中拷贝了对应子进程的数据，如果不会立马使用，就造成了空间的浪费。

所以OS提出了一种写时拷贝的技术来将父子进程的数据分离。

**写时拷贝本质是一种延迟申请，当你用的时候再给你，因此你不用的时候，不会占用资源，内存的使用效率非常高。提高了整机内存的使用率。**

因为有写时拷贝技术的存在，所以父子进程得以彻底分开。完成进程独立性的技术保证。

**写时拷贝是如何实现的呢?**
首先子进程在fork之后被创建出来，这里的创建出来，指的是对应的内核数据结构（task_struct，mm_struct，页表）和数据（代码和数据）都被创建出来。这时候，父子进程的内核数据结构二者是各自都有一份的。但是由于暂时没有写入的需求，因此在物理空间中，父子进程共用一块物理内存，而当子进程真正要写入数据的时候，OS会在对应的物理空间上开辟出一块全新的空间，将父进程的数据拷贝到子进程中去，子进程再对其进行修改，这样子就保证了进程的独立性，实现了父子进程的数据分离。同时这一种延迟申请的策略，也提高了整机的效率和空间的利用率。

**3 将子进程添加到系统进程的列表中去**
**4 fork返回，由调度器开始执行调度。(上下文切换)**
调度器决定进程如何调度，之后交由CPU执行。

那么，CPU是如何知道我们的程序执行到哪一行代码了的呢？比如说，如果程序中有循环语句等，执行完之后怎么记住这个入口的呢？

程序汇编之后，会有很多行代码，而且每行代码加载到内存中之后，都会产生对应的地址。

CPU运行其实就是取指令，分析指令，执行指令。进程在被CPU调度的时候随时可能被中断（而且可能并没有执行完 ），下次回来还必须从之前的位置继续运行，因此要求CPU必须随时记录下当前进程执行的位置。因此CPU内有对应的寄存器，用来记录当前进程的执行位置，它是EIP（PC指针）：程序计数器。EIP在其中扮演了一个类似于司令官的角色，他告诉CPU在哪执行。永远记录的是当前正在执行的代码的下一行代码的地址。（当前指令已经被执行了，不需要记录当前的位置了）比如当前指令的地址+当前指令的长度=下一条指令的地址，存储在PC指针中，这样子CPU就可以找到对应的执行位置了。

分析指令和执行指令的前提是CPU必须要认识指令，所以一般的CPU都有对应指令集。我的代码经过编译之后形成的汇编代码之后的二进制代码，对应的就叫做指令。

寄存器在CPU内只有一份，但是寄存器内的数据是可以有多份的。这个数据也被叫做上下文数据，被存储在task_struct中。当父进程创建子进程的时候，这个数据也是要以写时拷贝的技术交给子进程的。因此虽然父子进程各自调度，各自有自己的EIP，但是子进程依旧认为自己那一份EIP起始值是fork之后的代码。fork之后是所有的代码共享，但是有两个不同的执行流在被运行了。

总结上述过程：

fork创建子进程，相当于系统里多了一个进程，相当于加入了对应的pcb结构体，地址空间，页表 并将代码和数据加载到内存，构建映射关系。等待被调度。一旦CPU调度了这个进程，就可以通过映射关系来按照顺序和顺序语句，来执行进程内的代码完成各种业务。

进程=内核数据结构+进程的代码和数据（一般从磁盘中来，一般是C语言和c++程序，加载之后的结果）

**二 关于fork创建子进程的用法：**
1 父进程希望子进程复制自己，各自执行同一份代码的不同区域。

2 后续创建子进程，让父子进程分别执行不同的事情。


**三 关于fork调用失败的原因**
1 系统当中有太多的进程了

进程创建本质上消耗内存资源，一旦创建进程，那么系统中一定存在的大量的数据结构+代码本身的代码和数据，都是需要占用内存的，内存没有那么多了，就无法创建了。

2普通用户也无法创建很多的进程。

#### 3.5.2、加载和执行进程

exec() --> execute

<img src="计算机操作系统.assets/image-20221121210020557.webp" alt="image-20221121210020557" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121211241693.webp" alt="image-20221121211241693" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121211315561.webp" alt="image-20221121211315561" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121211350740.webp" alt="image-20221121211350740" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121211516251.webp" alt="image-20221121211516251" style="zoom:50%;" />

vfork()即前面创建线程时所说的**写时拷贝技术**

#### 3.5.3、等待和终止线程

<img src="计算机操作系统.assets/image-20221121212019919.webp" alt="image-20221121212019919" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121212326881.webp" alt="image-20221121212326881" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221121212443278.webp" alt="image-20221121212443278" style="zoom:50%;" />

## 4、CPU调度

### 4.1、背景

是TCB，不是TCP

<img src="计算机操作系统.assets/image-20221122112708822.webp" alt="image-20221122112708822" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122112930699.webp" alt="image-20221122112930699" style="zoom:50%;" />

现在的操作系统大多是可以抢占

### 4.2、调度原则

<img src="计算机操作系统.assets/image-20221122113706643.webp" alt="image-20221122113706643" style="zoom:50%;" />

调度的性能好坏指标：

<img src="计算机操作系统.assets/image-20221122113716725.webp" alt="image-20221122113716725" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122114102991.webp" alt="image-20221122114102991" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122114238429.webp" alt="image-20221122114238429" style="zoom:50%;" />

### 4.3、==调度算法==

<img src="计算机操作系统.assets/image-20221122114358670.webp" alt="image-20221122114358670" style="zoom:50%;" />

#### 4.3.1、先来先服务FCFS

<img src="计算机操作系统.assets/image-20221122114634381.webp" alt="image-20221122114634381" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122114717839.webp" alt="image-20221122114717839" style="zoom:50%;" />

#### 4.3.2、短进程优先SPN

<img src="计算机操作系统.assets/image-20221122114955978.webp" alt="image-20221122114955978" style="zoom:50%;" />

好处：平均等待时间最短

<img src="计算机操作系统.assets/image-20221122115218479.webp" alt="image-20221122115218479" style="zoom:50%;" />

缺点：因为可能不停有短任务添加进来，长任务就一直得不到执行

<img src="计算机操作系统.assets/image-20221122121735138.webp" alt="image-20221122121735138" style="zoom:50%;" />

#### 4.3.3、最高响应比优先HRRN

在SPN调度的基础上改进，比SPN多关注了等待时间，若下列计算的R值越大，则优先考虑

但是不支持抢占

<img src="计算机操作系统.assets/image-20221122123929735.webp" alt="image-20221122123929735" style="zoom:50%;" />

#### 4.3.4、轮循Round Robin

<img src="计算机操作系统.assets/image-20221122124219841.webp" alt="image-20221122124219841" style="zoom: 50%;" />

使得每个进程都有机会取使用CPU执行

<img src="计算机操作系统.assets/image-20221122124348458.webp" alt="image-20221122124348458" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122124509621.webp" alt="image-20221122124509621" style="zoom:50%;" />

#### 4.3.5、多级反馈队列MLFQ

<img src="计算机操作系统.assets/image-20221122124842870.webp" alt="image-20221122124842870" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122124853576.webp" alt="image-20221122124853576" style="zoom:50%;" />

#### 4.3.6、公平共享调度FSS

<img src="计算机操作系统.assets/image-20221122125144935.webp" alt="image-20221122125144935" style="zoom:50%;" />

#### 4.3.7、算法测评

<img src="计算机操作系统.assets/image-20221122125233785.webp" alt="image-20221122125233785" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122125339393.webp" alt="image-20221122125339393" style="zoom:50%;" />

### 4.4、实时调度(软硬时限)

<img src="计算机操作系统.assets/image-20221122130007260.webp" alt="image-20221122130007260" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122130050917.webp" alt="image-20221122130050917" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122130129397.webp" alt="image-20221122130129397" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122130239095.webp" alt="image-20221122130239095" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122130338083.webp" alt="image-20221122130338083" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122130509230.webp" alt="image-20221122130509230" style="zoom:50%;" />

RM：静态的，执行前就安排好优先级

EDF：动态的，执行过程中可根据deadline来调整优先级

<img src="计算机操作系统.assets/image-20221122130531305.webp" alt="image-20221122130531305" style="zoom:50%;" />

### 4.5、多处理器调度

<img src="计算机操作系统.assets/image-20221122131111371.webp" alt="image-20221122131111371" style="zoom:50%;" />

要保证负载平衡load balance

### 4.5、优先级反转

<img src="计算机操作系统.assets/image-20221122131433537.webp" alt="image-20221122131433537" style="zoom:50%;" />

问题：优先级：T1>T2>T3；T1和T3共享某一块资源，而正被T3占用，T1等待，T2抢占T3，于是T3等待，进而导致T1等待，而T1优先级高于T3，产生矛盾



<img src="计算机操作系统.assets/image-20221122131443763.webp" alt="image-20221122131443763" style="zoom:50%;" />

解决方法1：将T1和T3的优先级调换，这样T2就不能抢占T3了



<img src="计算机操作系统.assets/image-20221122133014006.webp" alt="image-20221122133014006" style="zoom:50%;" />

解决方法2：优先级天花板

<img src="计算机操作系统.assets/image-20221122133733190.webp" alt="image-20221122133733190" style="zoom:50%;" />

## 5、==进程互斥与同步-->同步==

### 5.1、背景知识

<img src="计算机操作系统.assets/image-20221122134042256.webp" alt="image-20221122134042256" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122134237929.webp" alt="image-20221122134237929" style="zoom:50%;" />

故需要线程同步

<img src="计算机操作系统.assets/image-20221122134320443.webp" alt="image-20221122134320443" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122134408602.webp" alt="image-20221122134408602" style="zoom:50%;" />

线程不同步会出现的问题：

<img src="计算机操作系统.assets/image-20221122141406196.webp" alt="image-20221122141406196" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122141656847.webp" alt="image-20221122141656847" style="zoom:50%;" />

### 5.2、一些概念

<img src="计算机操作系统.assets/image-20221122142033037.webp" alt="image-20221122142033037" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122142535409.webp" alt="image-20221122142535409" style="zoom:50%;" />

案例1：

<img src="计算机操作系统.assets/image-20221122143321822.webp" alt="image-20221122143321822" style="zoom:50%;" />

有三种结果，a赢，b赢，无输出

<img src="计算机操作系统.assets/image-20221122143627109.webp" alt="image-20221122143627109" style="zoom:50%;" />

案例2：

<img src="计算机操作系统.assets/image-20221122143818256.webp" alt="image-20221122143818256" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122143943649.webp" alt="image-20221122143943649" style="zoom:50%;" />



方法一：<img src="计算机操作系统.assets/image-20221122144354239.webp" alt="image-20221122144354239" style="zoom:50%;" />

这种方法不可行，因为：买面包可能会重复

<img src="计算机操作系统.assets/image-20221122144722289.webp" alt="image-20221122144722289" style="zoom:50%;" />

方法二：将noNote往前提也不行，直接不会有人买面包

<img src="计算机操作系统.assets/image-20221122144932459.webp" alt="image-20221122144932459" style="zoom:50%;" />

方法三：细分两个标签

<img src="计算机操作系统.assets/image-20221122145735713.webp" alt="image-20221122145735713" style="zoom:50%;" />

不可行

<img src="计算机操作系统.assets/image-20221122150048813.webp" alt="image-20221122150048813" style="zoom:50%;" />

方法四：有效，但是太复杂

<img src="计算机操作系统.assets/image-20221122150538551.webp" alt="image-20221122150538551" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122160821514.webp" alt="image-20221122160821514" style="zoom:50%;" />

更好的方法：

<img src="计算机操作系统.assets/image-20221122163222381.webp" alt="image-20221122163222381" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122163310084.webp" alt="image-20221122163310084" style="zoom:50%;" />

### 5.3、临界区

临界区的特点：

<img src="计算机操作系统.assets/image-20221122163440368.webp" alt="image-20221122163440368" style="zoom:50%;" />

### 5.4、==实现临界区的三种方法==

#### 5.4.1、方法1：禁用硬件中断(仅限于单处理器)

<img src="计算机操作系统.assets/image-20221122163815141.webp" alt="image-20221122163815141" style="zoom:50%;" />

缺点如下，且只适用单处理器，多CPU情况下不支持

<img src="计算机操作系统.assets/image-20221122163942727.webp" alt="image-20221122163942727" style="zoom:50%;" />

#### 5.4.2、方法2：基于软件的解决方法(复杂)

<img src="计算机操作系统.assets/image-20221122164243967.webp" alt="image-20221122164243967" style="zoom:50%;" />

##### 一些不可行方法：



<img src="计算机操作系统.assets/image-20221122164301840.webp" alt="image-20221122164301840" style="zoom:50%;" />

改进：

​		但是不能满足互斥

<img src="计算机操作系统.assets/image-20221122164747530.webp" alt="image-20221122164747530" style="zoom:50%;" />





<img src="计算机操作系统.assets/image-20221122165200208.webp" alt="image-20221122165200208" style="zoom:50%;" />

##### 最终解决方案：

<img src="计算机操作系统.assets/image-20221122165533790.webp" alt="image-20221122165533790" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122165647501.webp" alt="image-20221122165647501" style="zoom: 50%;" />

##### 对n个进程：

<img src="计算机操作系统.assets/image-20221122171035085.webp" alt="image-20221122171035085" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122171109658.webp" alt="image-20221122171109658" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122171235429.webp" alt="image-20221122171235429" style="zoom:50%;" />

#### 5.4.3、方法3：原子操作指令(单处理器多处理器均可)

<img src="计算机操作系统.assets/image-20221122172447655.webp" alt="image-20221122172447655" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122172458905.webp" alt="image-20221122172458905" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122172518324.webp" alt="image-20221122172518324" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122172953036.webp" alt="image-20221122172953036" style="zoom:50%;" />

若锁被释放，则占用锁

若锁处于忙状态，则死循环等待锁，即自旋spin，即忙等

<img src="计算机操作系统.assets/image-20221122173224630.webp" alt="image-20221122173224630" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122174150436.webp" alt="image-20221122174150436" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122174509608.webp" alt="image-20221122174509608" style="zoom:50%;" />

若临界区很短，则应该选择忙等，因为不用上下文切换，但浪费CPU时间

若临界区很长，则应该选择无忙等，但要上下文切换

<img src="计算机操作系统.assets/image-20221122175056064.webp" alt="image-20221122175056064" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122175211493.webp" alt="image-20221122175211493" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221122175220124.webp" alt="image-20221122175220124" style="zoom:50%;" />

#### 5.4.4、三种方法总结

<img src="计算机操作系统.assets/image-20221122175308528.webp" alt="image-20221122175308528" style="zoom:50%;" />

## 6、信号量与管程(互斥机制既可以通过上述的临界区来实现，也可以通过信号量和管程来实现)

### 6.1、背景

<img src="计算机操作系统.assets/image-20221123145048035.webp" alt="image-20221123145048035" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221123145056843.webp" alt="image-20221123145056843" style="zoom:50%;" />

### 6.2、信号量(定义)

信号sem表示还可以有多少个进程能够进入临界区。负值表示不能进入而且外面还有排队的进程。

p操作：对信号量减1，若结果大于等于0，则进程继续，否则执行p操作的进程被阻塞等待释放。
v操作：对信号量加1，若结果小于等于0，则唤醒队列中一个因为p操作而阻塞的进程。

进入临界区：执行p操作

离开临界区：执行v操作

<img src="计算机操作系统.assets/image-20221123171317446.webp" alt="image-20221123171317446" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221123172047727.webp" alt="image-20221123172047727" style="zoom:50%;" />

### 6.3、==信号量的使用(用法)==

<img src="计算机操作系统.assets/image-20221123172137581.webp" alt="image-20221123172137581" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221123174856160.webp" alt="image-20221123174856160" style="zoom:50%;" />

0和1可以代替之前的lock操作

<img src="计算机操作系统.assets/image-20221123185040409.webp" alt="image-20221123185040409" style="zoom:50%;" />

除了完成互斥操作，也可以完成同步：

<img src="计算机操作系统.assets/image-20221123185050155.webp" alt="image-20221123185050155" style="zoom:50%;" />

多个信号量操作：

计数信号量：

<img src="计算机操作系统.assets/image-20221123185906715.webp" alt="image-20221123185906715" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221123190148683.webp" alt="image-20221123190148683" style="zoom:50%;" />

二进制信号量为互斥信号量

后两个一般信号量为计数信号量

<img src="计算机操作系统.assets/image-20221123191503323.webp" alt="image-20221123191503323" style="zoom:50%;" />

改例既实现了互斥机制，又实现了同步机制

可将fullBuffers看成producerBuffers

将emptyBuffers看成productBuffers更好理解

只能先p操作，后v操作，否则会导致死锁

### 6.4、==信号量的实现(原理)==

#### 6.4.1、P、V操作的原理

<img src="计算机操作系统.assets/image-20221123192000803.webp" alt="image-20221123192000803" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221123192207726.webp" alt="image-20221123192207726" style="zoom:50%;" />

### 6.5、==管程==

<img src="计算机操作系统.assets/image-20221123192551417.webp" alt="image-20221123192551417" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221123192905428.webp" alt="image-20221123192905428" style="zoom:50%;" />

#### wait和signal的原理

<img src="计算机操作系统.assets/image-20221123193041269.webp" alt="image-20221123193041269" style="zoom:50%;" />



#### wait和signal的使用

<img src="计算机操作系统.assets/image-20221123193811437.webp" alt="image-20221123193811437" style="zoom:50%;" />





关于signal的使用问题：

<img src="计算机操作系统.assets/image-20221123194724505.webp" alt="image-20221123194724505" style="zoom:50%;" />

前一种是signal过后立即释放锁，后一种是让另一个线程运行一段时间后再释放锁

区别是：在deposit中，一个是while语句，一个是if语句

<img src="计算机操作系统.assets/image-20221123194913424.webp" alt="image-20221123194913424" style="zoom:50%;" />

#### 总结

​	临界区：lock.accquire()	等待锁释放后占有锁

​					lock.release()	释放锁，唤醒等待的进程

​	信号量：P()	sem--	if(sem<0)	等待

​					V()	sem++	if(sem<=0)	唤醒一个等待的P(一般是FIFO)

​	管程：	wait()	重新获得锁返回后，释放锁后睡眠

​					signal()（or broadcast()	如果有等待者，唤醒等待者（或所有等待者）

<img src="计算机操作系统.assets/image-20221123200028415.webp" alt="image-20221123200028415" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221123200109832.webp" alt="image-20221123200109832" style="zoom:50%;" />

### 6.7、经典同步问题

#### 读者-写者问题

##### 读者优先

<img src="计算机操作系统.assets/image-20221123215916061.webp" alt="image-20221123215916061" style="zoom:50%;" />

遵循读者”优先原则“，即一个写者先等待，再来一个读者，读者可插写者队

<img src="计算机操作系统.assets/image-20221123220056381.webp" alt="image-20221123220056381" style="zoom:50%;" />

用writePV操作封装write，实现互斥

用countPV封装Rcount的判断，实现互斥

如果当时Rcount=0，即没有writer，则用writePV封装read，实现互斥

<img src="计算机操作系统.assets/image-20221123234734967.webp" alt="image-20221123234734967" style="zoom:50%;" />

##### 写者优先

<img src="计算机操作系统.assets/image-20221124111544374.webp" alt="image-20221124111544374" style="zoom:50%;" />

上图上部分为一般思路，下部分为管程思路



读者操作：	<img src="计算机操作系统.assets/image-20221124112113678.webp" alt="image-20221124112113678" style="zoom:50%;" />

写者操作：

<img src="计算机操作系统.assets/image-20221124113601445.webp" alt="image-20221124113601445" style="zoom:50%;" />

#### 哲学家就餐问题

<img src="计算机操作系统.assets/image-20221124113817756.webp" alt="image-20221124113817756" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124114109691.webp" alt="image-20221124114109691" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124114146947.webp" alt="image-20221124114146947" style="zoom:50%;" />

若等待时间相同，则会一直做拿起放下操作

<img src="计算机操作系统.assets/image-20221124114400282.webp" alt="image-20221124114400282" style="zoom:50%;" />

用PV实现互斥，但只能有一个人同时吃饭，效率低

<img src="计算机操作系统.assets/image-20221124120414458.webp" alt="image-20221124120414458" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124120535387.webp" alt="image-20221124120535387" style="zoom:50%;" />



<img src="计算机操作系统.assets/image-20221124120622220.webp" alt="image-20221124120622220" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124120823850.webp" alt="image-20221124120823850" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124121117790.webp" alt="image-20221124121117790" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124132624723.webp" alt="image-20221124132624723" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124132705190.webp" alt="image-20221124132705190" style="zoom:50%;" />



take_forks():

<img src="计算机操作系统.assets/image-20221124133354837.webp" alt="image-20221124133354837" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124133813413.webp" alt="image-20221124133813413" style="zoom:50%;" />



put_forks():

<img src="计算机操作系统.assets/image-20221124150754829.webp" alt="image-20221124150754829" style="zoom:50%;" />

## 7、死锁(DeadLock)

### 7.1、死锁现象/问题

例如行车道：

<img src="计算机操作系统.assets/image-20221124151546518.webp" alt="image-20221124151546518" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221124151628969.webp" alt="image-20221124151628969" style="zoom:50%;" />

### 7.2、系统模型(死锁基本模型)

<img src="计算机操作系统.assets/image-20221124151807111.webp" alt="image-20221124151807111" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126114903239.webp" alt="image-20221126114903239" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126115117918.webp" alt="image-20221126115117918" style="zoom:50%;" />

P --> R : 进程P使用R这个资源

R --> P : 资源R被进程P使用

<img src="计算机操作系统.assets/image-20221126115258217.webp" alt="image-20221126115258217" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126115815055.webp" alt="image-20221126115815055" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126115907351.webp" alt="image-20221126115907351" style="zoom:50%;" />

死锁产生的典型特征：形成环，如上图形成了两个环、

但是有环不意味着死锁，如下图：

<img src="计算机操作系统.assets/image-20221126131221641.webp" alt="image-20221126131221641" style="zoom: 50%;" />

总结：

<img src="计算机操作系统.assets/image-20221126131350005.webp" alt="image-20221126131350005" style="zoom:50%;" />

### 7.3、死锁特征

<img src="计算机操作系统.assets/image-20221126131733947.webp" alt="image-20221126131733947" style="zoom:50%;" />

有死锁，一定会有这四个条件，但有这四个条件不一定有死锁

有死锁一定有环，没有死锁就没有环

### 7.4、死锁处理办法

<img src="计算机操作系统.assets/image-20221126132234548.webp" alt="image-20221126132234548" style="zoom:50%;" />

实际操作系统中，大多采用忽略死锁问题，因为处理死锁问题开销太大啊



目前操作系统采取忽略死锁，下列方法都只有局部性使用

#### 7.4.1、死锁预防和死锁避免

<img src="计算机操作系统.assets/image-20221126132359641.webp" alt="image-20221126132359641" style="zoom:50%;" />

只需将死锁四个特征，使其不能具备其一即可

或使死锁不能成环

<img src="计算机操作系统.assets/image-20221126132745547.webp" alt="image-20221126132745547" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126135301612.webp" alt="image-20221126135301612" style="zoom:50%;" />

判断是否处于安全状态（死锁包含于不安全状态），是通过判断是否会形成环，而不是是否死锁

<img src="计算机操作系统.assets/image-20221126135714286.webp" alt="image-20221126135714286" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126140058482.webp" alt="image-20221126140058482" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126140127517.webp" alt="image-20221126140127517" style="zoom:50%;" />

#### 7.4.2、银行家算法

<img src="计算机操作系统.assets/image-20221126140324392.webp" alt="image-20221126140324392" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126140420364.webp" alt="image-20221126140420364" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126141323169.webp" alt="image-20221126141323169" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126141610157.webp" alt="image-20221126141610157" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126141742764.webp" alt="image-20221126141742764" style="zoom:50%;" />

开销过大，实际操作系统很少用到

#### 7.4.3、死锁检测和死锁恢复

<img src="计算机操作系统.assets/image-20221126212006720.webp" alt="image-20221126212006720" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126212140341.webp" alt="image-20221126212140341" style="zoom:50%;" />

将资源分配图进行了简化，从左图简化为右图，去掉了资源部分

<img src="计算机操作系统.assets/image-20221126212259500.webp" alt="image-20221126212259500" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126212441877.webp" alt="image-20221126212441877" style="zoom:50%;" />

开销过大，实际操作系统很少用到，一般是在开发中用到



例子：

Allocation：已分配量

Request：请求量

Available：空闲量

<img src="计算机操作系统.assets/image-20221126212858549.webp" alt="image-20221126212858549" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126213044572.webp" alt="image-20221126213044572" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126213442949.webp" alt="image-20221126213442949" style="zoom:50%;" />



死锁恢复：

<img src="计算机操作系统.assets/image-20221126213524556.webp" alt="image-20221126213524556" style="zoom:50%;" />

都存在强制性和不合理性，因为进程都无法继续运行

所以死锁恢复是出现死锁的最后一种手段，即reboot、

<img src="计算机操作系统.assets/image-20221126213750414.webp" alt="image-20221126213750414" style="zoom:50%;" />

## 8、进程间通信(IPC)Inter Process Communication

### 8.1、概述

<img src="计算机操作系统.assets/image-20221126214923047.webp" alt="image-20221126214923047" style="zoom:50%;" />



#### 通信模型

<img src="计算机操作系统.assets/image-20221126215049771.webp" alt="image-20221126215049771" style="zoom:50%;" />

#### 直接及间接通信

<img src="计算机操作系统.assets/image-20221126215109064.webp" alt="image-20221126215109064" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126215131473.webp" alt="image-20221126215131473" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126215229266.webp" alt="image-20221126215229266" style="zoom:50%;" />

#### 阻塞与非阻塞

<img src="计算机操作系统.assets/image-20221126215305440.webp" alt="image-20221126215305440" style="zoom:50%;" />

#### 通信链路缓冲

<img src="计算机操作系统.assets/image-20221126215540528.webp" alt="image-20221126215540528" style="zoom:50%;" />

### 8.2、信号

<img src="计算机操作系统.assets/image-20221126215650699.webp" alt="image-20221126215650699" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126220140306.webp" alt="image-20221126220140306" style="zoom:50%;" />

### 8.3、管道

<img src="计算机操作系统.assets/image-20221126222209776.webp" alt="image-20221126222209776" style="zoom:50%;" />

### 8.4、消息队列

<img src="计算机操作系统.assets/image-20221126222223884.webp" alt="image-20221126222223884" style="zoom:50%;" />

### 8.5、共享内存

<img src="计算机操作系统.assets/image-20221126222349958.webp" alt="image-20221126222349958" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221126222814752.webp" alt="image-20221126222814752" style="zoom:50%;" />

#  三、文件管理

## 1、基本概念

### 1.1、文件系统和文件

<img src="计算机操作系统.assets/image-20221127150436582.webp" alt="image-20221127150436582" style="zoom:50%;" />

### 1.2、文件系统的功能

<img src="计算机操作系统.assets/image-20221127150715133.webp" alt="image-20221127150715133" style="zoom: 50%;" />

### 1.3、文件和块

文件头即是块

<img src="计算机操作系统.assets/image-20221127150900855.webp" alt="image-20221127150900855" style="zoom:50%;" />

### 1.4、文件描述符

<img src="计算机操作系统.assets/image-20221127151003027.webp" alt="image-20221127151003027" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127151124006.webp" alt="image-20221127151124006" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127151313179.webp" alt="image-20221127151313179" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127151947812.webp" alt="image-20221127151947812" style="zoom:50%;" />

即使只访问一个字节，也会缓存一个块的大小

<img src="计算机操作系统.assets/image-20221127152133436.webp" alt="image-20221127152133436" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127152237753.webp" alt="image-20221127152237753" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127152249831.webp" alt="image-20221127152249831" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127153235150.webp" alt="image-20221127153235150" style="zoom:50%;" />

### 1.5、目录

<img src="计算机操作系统.assets/image-20221127153615607.webp" alt="image-20221127153615607" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127153725260.webp" alt="image-20221127153725260" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127153739914.webp" alt="image-20221127153739914" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127153957526.webp" alt="image-20221127153957526" style="zoom:50%;" />

### 1.6、文件别名

<img src="计算机操作系统.assets/image-20221127154149439.webp" alt="image-20221127154149439" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127154338861.webp" alt="image-20221127154338861" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127154918092.webp" alt="image-20221127154918092" style="zoom:50%;" />

### 1.7、文件系统种类

<img src="计算机操作系统.assets/image-20221127155634164.webp" alt="image-20221127155634164" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127160533831.webp" alt="image-20221127160533831" style="zoom:50%;" />

## 2、虚拟文件系统

<img src="计算机操作系统.assets/image-20221127183557871.webp" alt="image-20221127183557871" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127183704597.webp" alt="image-20221127183704597" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127183716692.webp" alt="image-20221127183716692" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127183939412.webp" alt="image-20221127183939412" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127184431638.webp" alt="image-20221127184431638" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127184745545.webp" alt="image-20221127184745545" style="zoom:50%;" />

## 3、数据块缓存

<img src="计算机操作系统.assets/image-20221127184948501.webp" alt="image-20221127184948501" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127184958395.webp" alt="image-20221127184958395" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127185041739.webp" alt="image-20221127185041739" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127185152451.webp" alt="image-20221127185152451" style="zoom:50%;" />

## 4、打开文件的数据结构

<img src="计算机操作系统.assets/image-20221127185340729.webp" alt="image-20221127185340729" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127185413142.webp" alt="image-20221127185413142" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127185528887.webp" alt="image-20221127185528887" style="zoom:50%;" />

## 5、文件分配

<img src="计算机操作系统.assets/image-20221127185627119.webp" alt="image-20221127185627119" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127185643417.webp" alt="image-20221127185643417" style="zoom:50%;" />

### 连续分配：

<img src="计算机操作系统.assets/image-20221127185747467.webp" alt="image-20221127185747467" style="zoom:50%;" />

文件读取表现好，适合只读的文件

但对于增删很不方便，性能很糟糕



### 链式分配

<img src="计算机操作系统.assets/image-20221127190244195.webp" alt="image-20221127190244195" style="zoom:50%;" />

每次访问一个文件都必须从第一个快开始，不能真正的随机访问



### 索引分配

<img src="计算机操作系统.assets/image-20221127190505922.webp" alt="image-20221127190505922" style="zoom:50%;" />

应对大文件块：

<img src="计算机操作系统.assets/image-20221127190637889.webp" alt="image-20221127190637889" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127190841592.webp" alt="image-20221127190841592" style="zoom:50%;" />

## 6、空闲空间列表

<img src="计算机操作系统.assets/image-20221127190956451.webp" alt="image-20221127190956451" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127191044123.webp" alt="image-20221127191044123" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127191159855.webp" alt="image-20221127191159855" style="zoom:50%;" />

## 7、多磁盘管理RAID

磁盘模型：

<img src="计算机操作系统.assets/image-20221127191658347.webp" alt="image-20221127191658347" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127191754662.webp" alt="image-20221127191754662" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127192026891.webp" alt="image-20221127192026891" style="zoom:50%;" />

用多个便宜的硬盘组合成一个高容量高性能的硬盘、



raid0特点：提速

<img src="计算机操作系统.assets/image-20221127192227430.webp" alt="image-20221127192227430" style="zoom:50%;" />



raid1特点：镜像

<img src="计算机操作系统.assets/image-20221127192407683.webp" alt="image-20221127192407683" style="zoom:50%;" />



raid4特点：加速和镜像（raid0和raid1）

disk1，2，3，4实现加速，parity实现容错

若一个disk出错，可通过parity恢复（只能一个）

但会造成parity disk写操作很频繁

<img src="计算机操作系统.assets/image-20221127192540867.webp" alt="image-20221127192540867" style="zoom:50%;" />



raid5特点：（raid4更好的方法，也只能容错一个disk）

<img src="计算机操作系统.assets/image-20221127192733921.webp" alt="image-20221127192733921" style="zoom:50%;" />



总结

<img src="计算机操作系统.assets/image-20221127192912984.webp" alt="image-20221127192912984" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127193001292.webp" alt="image-20221127193001292" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127193011715.webp" alt="image-20221127193011715" style="zoom:50%;" />

## 8、磁盘调度

<img src="计算机操作系统.assets/image-20221127193245535.webp" alt="image-20221127193245535" style="zoom:50%;" />

图中一圈为一个磁道

<img src="计算机操作系统.assets/image-20221127194608700.webp" alt="image-20221127194608700" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127195143779.webp" alt="image-20221127195143779" style="zoom:50%;" />

<img src="计算机操作系统.assets/image-20221127195223330.webp" alt="image-20221127195223330" style="zoom:50%;" />



磁盘调度方法：

1、FIFO

<img src="计算机操作系统.assets/image-20221127200452606.webp" alt="image-20221127200452606" style="zoom:50%;" />

简单但不高效

2、最短服务优先

<img src="计算机操作系统.assets/image-20221127200553018.webp" alt="image-20221127200553018" style="zoom:50%;" />

可能会在一小块区域来回跳动，而不访问其他区域，容易出现饥饿现象

3、scan方法（电梯方法）

<img src="计算机操作系统.assets/image-20221127200659571.webp" alt="image-20221127200659571" style="zoom:50%;" />

4、c-scan方法

仅在一个方向上扫描，当扫描结束后重新回到起点，（自认为下图错误）

<img src="计算机操作系统.assets/image-20221127200920312.webp" alt="image-20221127200920312" style="zoom:50%;" />

5、c-look方法（c-scan改进）

到最后一个请求，而不是磁盘终点

<img src="计算机操作系统.assets/image-20221127201054544.webp" alt="image-20221127201054544" style="zoom:50%;" />

6、N-Step-SCAN方法

<img src="计算机操作系统.assets/image-20221127201228449.webp" alt="image-20221127201228449" style="zoom:50%;" />

7、将N赋值为2，则为F-scan方法

<img src="计算机操作系统.assets/image-20221127201353572.webp" alt="image-20221127201353572" style="zoom:50%;" />
